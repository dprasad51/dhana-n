<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Badminton Knockout Tournament</title>
<style>
  :root{
    --bg:#0f1115;
    --panel:#151923;
    --muted:#9aa4b2;
    --accent:#49a8ff;
    --accent-2:#7bdcff;
    --text:#f2f5f9;
    --error:#ff5370;

    --box-w: 150px;
    --box-h: 44px;
    --col-gap: 160px;   /* space between rounds */
    --h-gap: 22px;      /* line from box-right to junction */
    --row-gap: 24px;    /* gap inside a pair */
    --stack-gap: 40px;  /* gap between pairs */
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:var(--bg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial,'Noto Sans',sans-serif;
    color:var(--text);
  }
  header{
    padding:18px 20px;
    border-bottom:1px solid #1e2430;
    display:flex; gap:16px; align-items:center; flex-wrap:wrap;
    background:linear-gradient(180deg,#121723, #0f1115);
    position:sticky; top:0; z-index:5;
  }
  header h1{font-size:18px; margin:0; font-weight:700; letter-spacing:.2px}
  .controls{
    display:flex; gap:12px; align-items:center; flex-wrap:wrap;
  }
  .controls input[type="text"]{
    width:280px; padding:10px 12px; border-radius:10px; border:1px solid #1f2633;
    background:#0e1320; color:var(--text);
  }
  .controls textarea{
    width:380px; height:64px; padding:10px 12px; border-radius:10px; border:1px solid #1f2633;
    background:#0e1320; color:var(--text); resize:vertical;
  }
  .btn{
    padding:10px 14px; border-radius:10px; border:1px solid #1f2633; cursor:pointer;
    background:#121a2b; color:var(--text);
  }
  .btn.primary{ background:linear-gradient(180deg, #2a82ff, #1b73f8); border-color:#1b73f8; }
  .btn.ghost{ background:#0e1320; }
  .btn:disabled{ opacity:.6; cursor:not-allowed; }
  label{font-size:13px; color:var(--muted)}

  main{
    display:grid; grid-template-columns: 1fr 320px; gap:16px;
    padding:16px;
  }
  .board{
    position:relative; overflow:auto; background:radial-gradient(1200px 300px at 30% -10%,rgba(73,168,255,.08),transparent),
                                     radial-gradient(1200px 300px at 60% 110%,rgba(123,220,255,.06),transparent);
    border:1px solid #1e2430; border-radius:16px; min-height:70vh;
  }
  .board-inner{
    position:relative; margin:30px; min-width:900px; min-height:600px;
  }

  /* Bracket elements */
  .box{
    width:var(--box-w); height:var(--box-h);
    background:#121a2b;
    border:2px solid var(--accent);
    border-radius:10px;
    display:flex; align-items:center; justify-content:space-between;
    padding:0 10px; gap:6px;
    position:absolute;
    font-weight:600; letter-spacing:.2px;
    box-shadow:0 2px 0 rgba(0,0,0,.3), inset 0 0 0 1px rgba(255,255,255,.03);
  }
  .seed{
    font-size:11px; color:var(--muted);
    background:#0b1220; border:1px solid #1f2940; padding:3px 6px; border-radius:8px;
  }
  .name{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; flex:1; }

  .line { position:absolute; background:var(--accent); }
  .h-line{ height:2px; }
  .v-line{ width:2px; }

  /* Score widgets near the junction of each match */
  .scorecard{
    position:absolute; transform:translate(8px,-50%);
    background:var(--panel); border:1px solid #202637; border-radius:12px;
    display:flex; align-items:center; gap:6px; padding:6px 8px;
    box-shadow:0 10px 24px rgba(0,0,0,.25);
  }
  .scorecard input{
    width:44px; padding:6px 6px; border-radius:8px; border:1px solid #263149;
    background:#0e1320; color:var(--text); text-align:center;
  }
  .scorecard .vs{ font-size:12px; color:var(--muted); padding:0 2px; }
  .scorecard .small{ font-size:12px; color:#e6f2ff; }

  /* Stats panel */
  aside{
    border:1px solid #1e2430; border-radius:16px; padding:12px; background:#111520;
    position:sticky; top:80px; height: calc(100vh - 100px); overflow:auto;
  }
  aside h3{ margin:6px 8px 10px 8px; font-size:16px }
  table{ width:100%; border-collapse:separate; border-spacing:0 6px; }
  th, td{ font-size:12px; padding:6px 8px; text-align:right; }
  th:first-child, td:first-child{ text-align:left; }
  tr{
    background:#0e1320; border:1px solid #1f2633;
  }
  th{ color:var(--muted); background:#0b1019; position:sticky; top:0; z-index:1 }
  tr td.win{ color:#7bf2a7 }
  tr td.loss{ color:#ff9aa7 }

  .note{ font-size:12px; color:var(--muted); margin:8px 0 0 8px }

  .champ{
    background:linear-gradient(180deg,#1e2d45,#142034);
    border-color:var(--accent-2);
  }

  .legend{ font-size:12px; color:var(--muted); margin-left:auto; }
</style>
</head>
<body>
<header>
  <h1>üè∏ Badminton Knockout</h1>
  <div class="controls">
    <input id="playerName" type="text" placeholder="Add player name & press +"/>
    <button class="btn" id="addBtn">Ôºã Add</button>
    <textarea id="bulk" placeholder="Or paste names separated by comma or new lines"></textarea>
    <button class="btn" id="bulkBtn">Add List</button>
    <label><input type="checkbox" id="shuffle"/> Randomize seeding</label>
    <button class="btn primary" id="buildBtn">Generate Bracket</button>
    <button class="btn ghost" id="resetBtn">Reset</button>
    <span class="legend" id="playersCount">0 players</span>
  </div>
</header>

<main>
  <section class="board">
    <div class="board-inner" id="board"></div>
  </section>

  <aside>
    <h3>üìä Player Statistics</h3>
    <div class="note">Updates automatically when you save match scores.</div>
    <table>
      <thead>
        <tr>
          <th>Player</th><th>P</th><th>W</th><th>L</th><th>PF</th><th>PA</th><th>¬±</th>
        </tr>
      </thead>
      <tbody id="statsBody"></tbody>
    </table>
  </aside>
</main>

<script>
(function(){
  // ----- State -----
  const state = {
    players: [],       // [{name, seed}]
    rounds: [],        // rounds[r] = array of matches
    boxes: [],         // boxes[r][i] = element for participant box in round r (r=0 players)
    stats: new Map(),  // name -> {P,W,L,PF,PA}
  };

  // ----- DOM -----
  const el = (tag, cls, styles) => {
    const x = document.createElement(tag);
    if (cls) x.className = cls;
    if (styles) Object.assign(x.style, styles);
    return x;
  };

  const board = document.getElementById('board');
  const statsBody = document.getElementById('statsBody');
  const playerName = document.getElementById('playerName');
  const addBtn = document.getElementById('addBtn');
  const bulk = document.getElementById('bulk');
  const bulkBtn = document.getElementById('bulkBtn');
  const shuffle = document.getElementById('shuffle');
  const buildBtn = document.getElementById('buildBtn');
  const resetBtn = document.getElementById('resetBtn');
  const playersCount = document.getElementById('playersCount');

  addBtn.onclick = () => {
    const v = playerName.value.trim();
    if(!v) return;
    state.players.push({name: v});
    playerName.value = '';
    refreshPlayersCount();
  };
  playerName.addEventListener('keydown', e => { if(e.key==='Enter') addBtn.click(); });

  bulkBtn.onclick = () => {
    const list = bulk.value.split(/[\n,]+/).map(s=>s.trim()).filter(Boolean);
    list.forEach(n => state.players.push({name:n}));
    bulk.value = '';
    refreshPlayersCount();
  };

  resetBtn.onclick = () => {
    state.players = [];
    state.rounds = [];
    state.boxes = [];
    state.stats.clear();
    board.innerHTML = '';
    statsBody.innerHTML = '';
    refreshPlayersCount();
  };

  function refreshPlayersCount(){
    playersCount.textContent = `${state.players.length} player${state.players.length===1?'':'s'}`;
  }

  // ----- Build Bracket -----
  buildBtn.onclick = () => {
    if (state.players.length < 2){
      alert('Add at least 2 players.');
      return;
    }
    const n = nearestPowerOfTwo(state.players.length);
    if (n !== state.players.length) {
      alert(`Number of players must be a power of two. You have ${state.players.length}. (2,4,8,16,32,...)`);
      return;
    }

    const seeds = [...state.players];
    if (shuffle.checked) shuffleArray(seeds);

    // Init stats
    state.stats.clear();
    seeds.forEach((p,i) => {
      state.stats.set(p.name, {P:0,W:0,L:0,PF:0,PA:0});
      p.seed = i+1;
    });

    // Clear board
    board.innerHTML = '';
    state.rounds = [];
    state.boxes = [];

    layoutBracket(seeds.map(p=>p.name), seeds.map(p=>p.seed));
    renderStats();
  };

  // Layout constants
  const BOX_W = 150, BOX_H = 44, COL_GAP = 160, H_GAP = 22, ROW_GAP = 24, STACK_GAP = 40;

  function layoutBracket(namesRound0, seedsRound0){
    const roundsCount = Math.log2(namesRound0.length);
    const totalWidth = roundsCount * (BOX_W + COL_GAP) + BOX_W + 100;
    const totalHeight = computeBoardHeight(namesRound0.length);
    board.style.width = totalWidth+'px';
    board.style.height = totalHeight+'px';

    // Build round 0 boxes
    state.boxes[0] = [];
    const centers0 = [];
    for (let i=0;i<namesRound0.length;i++){
      const col = 0, left = col*(BOX_W+COL_GAP);
      const top = topForIndex(i);
      const b = createBox(namesRound0[i], seedsRound0[i], left, top);
      board.appendChild(b);
      state.boxes[0].push(b);
      centers0.push(centerY(top));
    }

    // For each subsequent round
    let prevCenters = centers0;
    let prevNames = namesRound0;
    let prevSeeds = seedsRound0;
    for (let r=0; r<roundsCount; r++){
      const matches = [];
      state.boxes[r+1] = [];
      const nextCenters = [];
      const nextNames = new Array(prevNames.length/2).fill('');
      const nextSeeds = new Array(prevSeeds.length/2).fill('');

      const colLeft = (r)*(BOX_W+COL_GAP);
      const colRight = (r+1)*(BOX_W+COL_GAP);
      const junctionX = colLeft + BOX_W + H_GAP;

      for (let m=0; m<prevNames.length/2; m++){
        const iA = 2*m, iB = 2*m+1;
        const yA = prevCenters[iA], yB = prevCenters[iB];
        const midY = (yA + yB)/2;

        // Lines from A and B to junction (horizontal)
        const bA = state.boxes[r][iA], bB = state.boxes[r][iB];
        // A
        addHLine(bA, junctionX);
        // B
        addHLine(bB, junctionX);
        // Vertical line between A and B at junction
        addVLine(junctionX, yA, yB);
        // Winner horizontal to next round box-left
        const winnerLeft = colRight;
        addHLineFromPoint(junctionX, midY, winnerLeft);

        // Create winner box in next round at midY
        const winnerTop = midY - BOX_H/2;
        const winnerBox = createBox('‚Äî', '', winnerLeft, winnerTop, r === roundsCount-1 ? true : false);
        board.appendChild(winnerBox);
        state.boxes[r+1].push(winnerBox);
        nextCenters.push(midY);

        // Score card for this match (positioned at junction)
        createScoreCard({
          round:r, match:m,
          a: { name: prevNames[iA], seed: prevSeeds[iA], box: bA },
          b: { name: prevNames[iB], seed: prevSeeds[iB], box: bB },
          targetBox: winnerBox,
          x: junctionX, y: midY,
          onWinner:(winner, loser, sa, sb)=>{
            // Push forward the name
            winnerBox.dataset.name = winner;
            winnerBox.querySelector('.name').textContent = winner;
            // For next round arrays
            nextNames[m] = winner;
            nextSeeds[m] = ''; // seed no longer relevant
            // Update stats
            updateStats(winner, loser, sa, sb);
            renderStats();

            // If all matches of this round are decided, ensure connectors for next round are drawn (already drawn)
            // If final decided, mark champion
            if (r === roundsCount-1){
              winnerBox.classList.add('champ');
              winnerBox.querySelector('.seed').textContent = 'üèÜ';
            }
          }
        });

        matches.push({A:iA, B:iB, midY, winnerBox});
      }

      state.rounds[r] = matches;
      prevCenters = nextCenters;
      prevNames = nextNames;
      prevSeeds = nextSeeds;
    }
  }

  // ---- Geometry helpers ----
  function centerY(top){ return top + BOX_H/2; }
  function topForIndex(i){
    // For round 0: boxes come in pairs:
    // pair height = BOX_H*2 + ROW_GAP
    const pair = Math.floor(i/2);
    const idxInPair = i%2; // 0 or 1
    const pairStartTop = pair*(BOX_H*2 + ROW_GAP + STACK_GAP);
    return pairStartTop + idxInPair*(BOX_H + ROW_GAP);
  }
  function computeBoardHeight(n){
    const pairs = n/2;
    return pairs*(BOX_H*2 + ROW_GAP + STACK_GAP) - STACK_GAP + 60;
  }

  // ---- Rendering pieces ----
  function createBox(name, seed, left, top, isChampion=false){
    const d = el('div','box', {left:left+'px', top:top+'px', width:BOX_W+'px', height:BOX_H+'px'});
    const s = el('div','seed');
    s.textContent = seed ? `#${seed}` : (isChampion ? 'üèÜ' : '');
    const nm = el('div','name'); nm.textContent = name || '‚Äî';
    d.append(s, nm);
    d.dataset.name = name || '';
    return d;
  }
  function addHLine(boxEl, junctionX){
    const rectLeft = parseFloat(boxEl.style.left);
    const y = centerY(parseFloat(boxEl.style.top));
    const x1 = rectLeft + BOX_W;
    const w = junctionX - x1;
    const line = el('div','line h-line',{ left:x1+'px', top:(y-1)+'px', width:w+'px' });
    board.appendChild(line);
  }
  function addHLineFromPoint(xStart, y, boxLeft){
    const w = boxLeft - xStart;
    const line = el('div','line h-line',{ left:xStart+'px', top:(y-1)+'px', width:w+'px' });
    board.appendChild(line);
  }
  function addVLine(x, y1, y2){
    const top = Math.min(y1,y2);
    const h = Math.abs(y2-y1);
    const v = el('div','line v-line',{ left:(x-1)+'px', top:top+'px', height:h+'px' });
    board.appendChild(v);
  }

  // Scorecard for a match (two inputs + save)
  function createScoreCard({round, match, a, b, targetBox, x, y, onWinner}){
    const card = el('div','scorecard', { left:x+'px', top:y+'px' });
    const inA = el('input'); inA.type='number'; inA.min='0'; inA.placeholder='A';
    const vs = el('span','vs'); vs.textContent = '‚Äî';
    const inB = el('input'); inB.type='number'; inB.min='0'; inB.placeholder='B';
    const save = el('button','btn small'); save.textContent='Save';
    const label = el('span','small');
    label.textContent = `${a.name} vs ${b.name}`;
    card.prepend(label);
    card.append(inA, vs, inB, save);
    board.appendChild(card);

    let locked = false;

    save.onclick = () => {
      if (locked) return;
      const sa = parseInt(inA.value,10);
      const sb = parseInt(inB.value,10);
      if (Number.isNaN(sa) || Number.isNaN(sb)) { alert('Enter scores for both players.'); return; }
      if (sa===sb){ alert('Scores cannot be equal.'); return; }
      const winner = sa>sb ? a.name : b.name;
      const loser  = sa>sb ? b.name : a.name;

      // Visual: put winner name into next box
      targetBox.dataset.name = winner;
      targetBox.querySelector('.name').textContent = winner;

      // mark winner/loser styles on current boxes (optional subtle color)
      a.box.style.borderColor = sa>sb ? '#6ee7b7' : '#ff9aa7';
      b.box.style.borderColor = sb>sa ? '#6ee7b7' : '#ff9aa7';

      if (onWinner) onWinner(winner, loser, sa, sb);

      // lock
      inA.disabled = inB.disabled = true;
      save.disabled = true;
      locked = true;
    };
  }

  // ---- Stats ----
  function updateStats(winner, loser, sw, sl){
    const w = state.stats.get(winner);
    const l = state.stats.get(loser);
    if(!w || !l) return;
    w.P++; w.W++; w.PF += sw; w.PA += sl;
    l.P++; l.L++; l.PF += sl; l.PA += sw;
  }
  function renderStats(){
    const rows = [];
    state.stats.forEach((v,k) => {
      rows.push({name:k, ...v, diff:v.PF - v.PA});
    });
    // sort by Wins desc, then diff desc, then PF desc
    rows.sort((a,b)=> b.W - a.W || b.diff - a.diff || b.PF - a.PF || a.name.localeCompare(b.name));
    statsBody.innerHTML = rows.map(r => `
      <tr>
        <td>${esc(r.name)}</td>
        <td>${r.P}</td>
        <td class="win">${r.W}</td>
        <td class="loss">${r.L}</td>
        <td>${r.PF}</td>
        <td>${r.PA}</td>
        <td>${r.diff>=0?'+':''}${r.diff}</td>
      </tr>
    `).join('');
  }

  // ---- Utils ----
  function nearestPowerOfTwo(n){
    // require exact power of two
    return (n & (n-1)) === 0 ? n : -1;
  }
  function shuffleArray(a){
    for(let i=a.length-1;i>0;i--){
      const j = (Math.random()* (i+1))|0;
      [a[i],a[j]]=[a[j],a[i]];
    }
  }
  function esc(s){ return s.replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

})();
</script>
</body>
</html>
